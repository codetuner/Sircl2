<html>
<head>
    <title>Arebis MvcDashboardLocalize ReadMe</title>
    <style>
        html {
            font-family: Verdana, Geneva, Tahoma, sans-serif;
        }

        pre {
            padding: 12px;
            border-radius: 4px;
            background-color: lavenderblush;
            overflow: auto;
        }

        code {
            font-size: 120%;
        }

        .highlight {
            background-color: yellow;
        }

        .old-code {
            background-color: lightgray;
        }

        .new-code {
            background-color: yellow;
        }
    </style>
</head>
<body>
    <h1>Arebis MvcDashboardLocalize</h1>

    <h2>Introduction</h2>

    <p>
        Arebis MvcDashboardLocalize is an ASP.NET Core dashboard area that provides access to a localization database.
    </p>

    <p>
        It assumes an ASP.NET MVC website having access to a SQL Server database.
    </p>

    <h2>Setup</h2>

    <p>After installing the dashboard area, follow these steps:</p>

    <p>**** TO REVIEW WHAT FOLLOWS ***</p>


    <p>**** ALSO TALK ABOUT BinaryFormatter *****</p>

    <h3>CompiledDataFileName setting</h3>

    <p>
        The <code>CompiledDataFileName</code> setting declares a file path/name to which to store 'compiled' localization data. Using this file has two benefits:
    </p>
    <ol>
        <li>Faster loading of localization data after an application restart: it's faster to reconstruct the localization data from a binary format serialized file than it is from various database queries.</li>
        <li>Better control over when to 'publish' localization data: using a data file means localization data is retrieved from database only on explicit request and not when the application restarts.</li>
    </ol>

    <p>
        The setting can be declared in the <code>appsettings.json</code> file, as follows:
    </p>

<pre>"Localization": {
    "CompiledDataFileName": "LocalizationData.bin"
}</pre>

    <p>
        Or in the Startup class,
    </p>

<pre>services.AddArebisLocalization(Configuration, options =&gt; {
    options.CompiledDataFileName = "LocalizationData.bin";
    options.Domains = new string[] { "Base", "Trading", "TradingWebApp" };
});</pre>

    <p>
        However, Microsoft decided to discourage the use of BinaryFormatter for security reasons.
        The argument is rightfully that binary serialization of data that is not trusted, can be dangerous. For this reason, you should ensure that the compiled data file is stored on a secured, trustworthy location. With the same security level as the compiled code of your application.<br />
        If done so, there should be no real concern about using binary serialization, and the benefit of performance (both on speed of processing as on memory consumption of the deserialization process) are a good argument in favor of using this type of serialization.
    </p>

    <p>
        The choice is up to you. If you do use the <code>CompiledDataFileName</code> setting, you should also enable binary serialization using the following configuration in ASP.NET project files:
    </p>

<pre>&lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
    &lt;!-- Warning: Setting the following switch is *NOT* recommended in web apps. --&gt;
    &lt;EnableUnsafeBinaryFormatterSerialization&gt;true&lt;/EnableUnsafeBinaryFormatterSerialization&gt;
&lt;/PropertyGroup&gt;</pre>

    <p>
        If you do not use the <code>CompiledDataFileName</code> setting, localization data will be retrieved from database on every startup of the application and on explicit request.
    </p>

    <p>For more information, see: <a href="https://docs.microsoft.com/en-us/dotnet/core/compatibility/core-libraries/5.0/binaryformatter-serialization-obsolete">BinaryFormatter serialization methods are obsolete and prohibited in ASP.NET apps</a>.</p>

    <p>**** *****</p>

    <h3>Register ContentDbContext</h3>

    <p>To register the ContentDbContext, add the following line of code to the ConfigureServices method of the Startup class of your project:</p>
<pre>
<b><span class="new-code">services.AddDbContext&lt;Data.Content.ContentDbContext&gt;(options =&gt;
    options.UseSqlServer(
        Configuration.GetConnectionString("DefaultConnection")));</span></b>
</pre>

    <p>If you do not yet have a <code>"DefaultConnection"</code>, or whish to use a different connection, do not forget to register the connection in the ConnectionStrings section of your appsettings.js file.</p>

    <h3>Add routing for the MvcDashboardContent area and for content rendering</h3>

    <p>
        Configure the following routes in the Configure method of your Startup class:
    </p>

<pre>
app.UseEndpoints(endpoints =>
{
<b><span class="new-code">    endpoints.MapAreaControllerRoute(null, "MvcDashboardContent", "MvcDashboardContent/{controller=Home}/{action=Index}/{id?}");</span></b>
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
    endpoints.MapRazorPages();
<b><span class="new-code">    endpoints.MapControllerRoute(
        name: "content",
        pattern: "{**path}",
        defaults: new { controller = "Content", action = "Render" });</span></b>
});
</pre>

    <p>The first registration (using MapAreaControllerRoute) will register the MvcDashbboardContent area and make the content manager dashboard available on the <code>/MvcDashboardContent</code> URL.</p>

    <p>The last registration (using MapControllerRoute) <b>must be the very last endpoint</b> you register, as it will catch all remaining requests and send them to the ContentController which will try to render them based on the created documents.</p>

    <p>It is up to you to modify the pattern by adding a culture segment if you are using the <code>RouteDataRequestCultureProvider</code>, or a route prefix if you whish so.</p>

    <h3>Update Database</h3>

    <p>Before running the application, make sure the database structure is extended with the <code>content</code> schema.</p>

    <p>Call the following command from the Visual Studio Package Manager Console to create the <code>content</code> schema in your database:</p>

<pre>
PM&gt; <b>Update-Database -Context "ContentDbContext"</b>
</pre>

    <h2>Security</h2>

    <p>The MvcDashboardContent is secured with role-based security. Following roles are supported:</p>

    <ul>
        <li>
            <b>Administrator</b><br />



            A global administrator role that has full access.
        </li>
        <li>
            <b>ContentAdministrator</b><br />



            A content administrator role that has full access.
        </li>
        <li>
            <b>ContentEditor</b><br />



            A content editor role that can create, review and publish content, but cannot create or change document types nor change path security settings.
        </li>
        <li>
            <b>ContentAuthor</b><br />



            A content author role that can create and edit unpublished documents, as well as request publication, but cannot actually publish. Document types and path security settings are also unavailable to this role.
        </li>
    </ul>

    <p>Note that the MvcDashboardContent only uses role-based security. As a consequence, an author that can edit documents, can edit all of them, not only the documents he created.</p>

    <p>It is up to you to assign the correct roles to the users. If you are using ASP.NET Core Identities, you can do so using the Arebis MvcDashboardIdentity.</p>

    <hr />



</body>
</html>
